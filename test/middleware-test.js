'use strict';

const expect = require('chai').expect;
const RSVP = require('rsvp');
const broccoliMiddleware = require('./../lib/index').watcherServerMiddleware;
const fixture = require('./helpers/fixture-path');
const TestHTTPServer = require('./helpers/test-http-server');

describe('broccoli-middleware', function() {
  describe('watcher resolves correctly', function() {
    let server;

    afterEach(() => {
      server.stop();
      server = null;
    })

    it('responds with the given file if file is on disk', function() {
      const watcher = RSVP.Promise.resolve({
        'directory': fixture('basic-file')
      });
      const middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then((info) => {
          return server.request('/index.html', {
            info
          });
        })
        .then((content) => {
          expect(content).to.match(/This is broccoli middleware page/);
        });
    });

    it('responds with error if file not found', function(done) {
      const watcher = RSVP.Promise.resolve({
        'directory': fixture('basic-file')
      });

      const middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      const wrapperMiddleware = (req, resp /*next*/) => {
        middleware(req, resp, () => {
          const isRequestFinished = resp.finished;
          expect(isRequestFinished).to.be.false;
          done();
        })
      };

      server = new TestHTTPServer(wrapperMiddleware);
      server.start()
        .then((info) => {
          return server.request('/non-existent-file', {
            info
          });
        });
    });

    it('bypasses broccoli-middleware if request is a directory and autoIndex is set to false', function(done) {
      const watcher = RSVP.Promise.resolve({
        'directory': fixture('no-index')
      });

      const middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      const wrapperMiddleware = (req, resp /*next*/) => {
        middleware(req, resp, () => {
          const isRequestFinished = resp.finished;
          expect(isRequestFinished).to.be.false;
          done();
        })
      };
      server = new TestHTTPServer(wrapperMiddleware);

      server.start()
        .then((info) => {
          return server.request('', {
            info
          });
        });
    });

    it('responds with directory structure template if request is a directory and autoIndex is set to true', function() {
      const watcher = RSVP.Promise.resolve({
        'directory': fixture('no-index')
      });

      const middleware = broccoliMiddleware(watcher, {
        autoIndex: true
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then((info) => {
          return server.request('', {
            info
          });
        })
        .then(function(content) {
          expect(content).to.match(/Generated by Broccoli/);
        });
    });

    it('responds with index.html if request is a directory and autoIndex is set to true', function() {
      const watcher = RSVP.Promise.resolve({
        'directory': fixture('basic-file')
      });
      const middleware = broccoliMiddleware(watcher, {
        autoIndex: true
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then((info) => {
          return server.request('', {
            info
          });
        })
        .then(function(content) {
          expect(content).to.match(/This is broccoli middleware page/);
        });
    });
  });

  describe('watcher is rejected', function() {
    let watcher;
    let server;

    beforeEach(() => {
      watcher = RSVP.Promise.reject({
        stack: 'Build error',
        broccoliPayload: {
          error: {
            message: 'Broccoli files messed up'
          }
        }
      });

      watcher['builder'] = {};
    });

    afterEach(() => {
      server.stop();
      server = null;
    })

    it('returns HTTP 500 when there is build error', function() {
      const middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then((info) => {
          return server.request('/index.html', {
            info
          });
        })
        .catch(function(error) {
          expect(error).to.match(/StatusCodeError: 500/);
        });
    });
  });

  describe('watcher is without broccoli specific error payload', function() {
    let watcher;
    let server;

    beforeEach(() => {
      watcher = RSVP.Promise.reject({
        stack: 'Build error'
      });

      watcher['builder'] = {};
    });

    afterEach(() => {
      server.stop();
      server = null;
    })

    it('returns HTTP 500 when there is build error', function() {
      const middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then((info) => {
          return server.request('/index.html', {
            info
          });
        })
        .catch(function(error) {
          expect(error).to.match(/StatusCodeError: 500/);
        });
    });
  });

  describe('formats build errors', function() {
    let server;

    afterEach(() => {
      server.stop();
      server = null;
    })

    it('converts ANSI codes to HTML from the error stack', function() {
      let watcher = RSVP.Promise.reject({
        broccoliPayload: {
          error: {
            message: 'Babel ran into an error',
            stack: '\u001b[35m102\u001b[39m\u001b[33m\u001b[0m'
          }
        }
      });

      watcher['builder'] = {};

      const middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then((info) => {
          return server.request('/index.html', {
            info
          });
        })
        .catch(function(error) {
          expect(error.error).to.include('<span style="color:#ff00ff;">102</span>');
        });
    });

    it('escapes error messages when there are no ANSI codes', function() {
      let watcher = RSVP.Promise.reject({
        broccoliPayload: {
          error: {
            message: 'Babel ran into an error',
            // eslint-disable-next-line quotes
            stack: `{{/if}</div>\n-----^\nExpecting 'CLOSE_RAW_BLOCK', 'CLOSE', 'CLOSE_UNESCAPED', 'OPEN_SEXPR', 'CLOSE_SEXPR', 'ID', 'OPEN_BLOCK_PARAMS', 'STRING', 'NUMBER', 'BOOLEAN', 'UNDEFINED', 'NULL', 'DATA', 'SEP', got 'INVALID'`
          }
        }
      });

      watcher['builder'] = {};

      const middleware = broccoliMiddleware(watcher, {
        autoIndex: false
      });

      server = new TestHTTPServer(middleware);

      return server.start()
        .then((info) => {
          return server.request('/index.html', {
            info
          });
        })
        .catch(function(error) {
          expect(error.error).to.include('{{/if}&lt;/div&gt;\n-----^\nExpecting &#x27;CLOSE_RAW_BLOCK&#x27;, &#x27;CLOSE&#x27;, &#x27;CLOSE_UNESCAPED&#x27;, &#x27;OPEN_SEXPR&#x27;, &#x27;CLOSE_SEXPR&#x27;, &#x27;ID&#x27;, &#x27;OPEN_BLOCK_PARAMS&#x27;, &#x27;STRING&#x27;, &#x27;NUMBER&#x27;, &#x27;BOOLEAN&#x27;, &#x27;UNDEFINED&#x27;, &#x27;NULL&#x27;, &#x27;DATA&#x27;, &#x27;SEP&#x27;, got &#x27;INVALID&#x27;');
        });
    });
  });
});
